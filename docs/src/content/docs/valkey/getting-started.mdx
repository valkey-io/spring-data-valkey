---
title: Getting Started
description: Getting Started documentation
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

An easy way to bootstrap setting up a working environment is to create a Spring-based project via [start.spring.io](https://start.spring.io/#!type=maven-project&dependencies=data-valkey) or create a Spring project in [Spring Tools](https://spring.io/tools).
## Examples Repository

The GitHub [spring-data-examples repository](https://github.com/spring-projects/spring-data-examples) hosts several examples that you can download and play around with to get a feel for how the library works.
## Hello World

First, you need to set up a running Valkey server.
Spring Data Valkey requires Valkey 2.6 or above and Spring Data Valkey integrates with [Lettuce](https://github.com/lettuce-io/lettuce-core) and [Jedis](https://github.com/valkey/jedis), two popular open-source Java libraries for Valkey.

Now you can create a simple Java application that stores and reads a value to and from Valkey.

Create the main application to run, as the following example shows:

<Tabs>
<TabItem label="Imperative">

```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import io.valkey.springframework.data.connection.ValkeyConnectionFactory;
import io.valkey.springframework.data.connection.lettuce.LettuceConnectionFactory;
import io.valkey.springframework.data.core.ValkeyTemplate;

public class ValkeyApplication {

	private static final Log LOG = LogFactory.getLog(ValkeyApplication.class);

	public static void main(String[] args) {

		ValkeyConnectionFactory factory = new LettuceConnectionFactory();

		ValkeyTemplate<String, String> template = new ValkeyTemplate<>();
		template.setConnectionFactory(factory);
		template.afterPropertiesSet();

		template.opsForValue().set("foo", "bar");

		LOG.info("Value at foo:" + template.opsForValue().get("foo"));

		template.getConnectionFactory().getConnection().close();
	}
}
```

</TabItem>
<TabItem label="Reactive">

```java
import reactor.core.publisher.Mono;

import io.valkey.springframework.data.connection.ReactiveValkeyConnectionFactory;
import io.valkey.springframework.data.connection.lettuce.LettuceConnectionFactory;
import io.valkey.springframework.data.core.ReactiveValkeyTemplate;
import io.valkey.springframework.data.serialization.ValkeySerializationContext;

public class ReactiveValkeyApplication {

	public static void main(String[] args) {

		ReactiveValkeyConnectionFactory factory = new LettuceConnectionFactory();

		ReactiveValkeyTemplate<String, String> template = new ReactiveValkeyTemplate<>(factory, ValkeySerializationContext.string());

		template.opsForValue().set("foo", "bar")
			.then(template.opsForValue().get("foo"))
			.doOnNext(System.out::println)
			.then(Mono.fromRunnable(() -> factory.getReactiveConnection().close()))
			.subscribe();
	}
}
```

</TabItem>
</Tabs>
Even in this simple example, there are a few notable things to point out:

* You can create an instance of `io.valkey.springframework.data.core.ValkeyTemplate` (or `io.valkey.springframework.data.core.ReactiveValkeyTemplate`for reactive usage) with a `io.valkey.springframework.data.connection.ValkeyConnectionFactory`. Connection factories are an abstraction on top of the supported drivers.
* There's no single way to use Valkey as it comes with support for a wide range of data structures such as plain keys ("strings"), lists, sets, sorted sets, streams, hashes and so on.
