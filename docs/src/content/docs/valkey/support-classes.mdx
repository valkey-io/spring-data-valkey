---
title: Support Classes
description: Support Classes documentation
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Package `io.valkey.springframework.data.support` offers various reusable components that rely on Valkey as a backing store.
Currently, the package contains various JDK-based interface implementations on top of Valkey, such as [atomic](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html) counters and JDK [Collections](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html).

:::note
`io.valkey.springframework.data.support.collections.ValkeyList` is forward-compatible with Java 21 `SequencedCollection`.
:::

The atomic counters make it easy to wrap Valkey key incrementation while the collections allow easy management of Valkey keys with minimal storage exposure or API leakage.
In particular, the `io.valkey.springframework.data.support.collections.ValkeySet` and `io.valkey.springframework.data.support.collections.ValkeyZSet` interfaces offer easy access to the set operations supported by Valkey, such as `intersection` and `union`. `io.valkey.springframework.data.support.collections.ValkeyList` implements the `List`, `Queue`, and `Deque` contracts (and their equivalent blocking siblings) on top of Valkey, exposing the storage as a FIFO (First-In-First-Out), LIFO (Last-In-First-Out) or capped collection with minimal configuration.
The following example shows the configuration for a bean that uses a `io.valkey.springframework.data.support.collections.ValkeyList`:

<Tabs>
<TabItem label="Java">

```java
@Configuration
class MyConfig {

  // â€¦

  @Bean
  ValkeyList<String> stringValkeyTemplate(ValkeyTemplate<String, String> valkeyTemplate) {
    return new DefaultValkeyList<>(template, "queue-key");
  }
}
```

</TabItem>
<TabItem label="XML">

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="
  http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="queue" class="io.valkey.springframework.data.support.collections.DefaultValkeyList">
    <constructor-arg ref="valkeyTemplate"/>
    <constructor-arg value="queue-key"/>
  </bean>

</beans>
```

</TabItem>
</Tabs>

The following example shows a Java configuration example for a `Deque`:

```java
public class AnotherExample {

  // injected
  private Deque<String> queue;

  public void addTag(String tag) {
    queue.push(tag);
  }
}
```

As shown in the preceding example, the consuming code is decoupled from the actual storage implementation.
In fact, there is no indication that Valkey is used underneath.
This makes moving from development to production environments transparent and highly increases testability (the Valkey implementation can be replaced with an in-memory one).
